/*
  Copyright 2019 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/

import {Deferred} from 'workbox-core/_private/Deferred.js';
import {dontWaitFor} from 'workbox-core/_private/dontWaitFor.js';
import {logger} from 'workbox-core/_private/logger.js';
import {TrustedScriptURL} from 'trusted-types/lib';

import {messageSW} from './messageSW.js';
import {WorkboxEventTarget} from './utils/WorkboxEventTarget.js';
import {urlsMatch} from './utils/urlsMatch.js';
import {WorkboxEvent, WorkboxLifecycleEventMap} from './utils/WorkboxEvent.js';

import './_version.js';

// The time a SW must be in the waiting phase before we can conclude
// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically
// chosen, but it seems to avoid false positives in my testing.
const WAITING_TIMEOUT_DURATION = 200;

// The amount of time after a registration that we can reasonably conclude
// that the registration didn't trigger an update.
const REGISTRATION_TIMEOUT_DURATION = 60000;

// The de facto standard message that a service worker should be listening for
// to trigger a call to skipWaiting().
const SKIP_WAITING_MESSAGE = {type: 'SKIP_WAITING'};

/**
 * A class to aid in handling service worker registration, updates, and
 * reacting to service worker lifecycle events.
 *
 * @fires {@link workbox-window.Workbox#message}
 * @fires {@link workbox-window.Workbox#installed}
 * @fires {@link workbox-window.Workbox#waiting}
 * @fires {@link workbox-window.Workbox#controlling}
 * @fires {@link workbox-window.Workbox#activated}
 * @fires {@link workbox-window.Workbox#redundant}
 * @memberof workbox-window
 */
class Workbox extends WorkboxEventTarget {
  private readonly _scriptURL: string | TrustedScriptURL;
  private readonly _registerOptions: RegistrationOptions = {};
  private _updateFoundCount = 0;

  // Deferreds we can resolve later.
  private readonly _swDeferred: Deferred<ServiceWorker> = new Deferred();
  private readonly _activeDeferred: Deferred<ServiceWorker> = new Deferred();
  private readonly _controllingDeferred: Deferred<ServiceWorker> =
    new Deferred();

  private _registrationTime: DOMHighResTimeStamp = 0;
  private _isUpdate?: boolean;
  private _compatibleControllingSW?: ServiceWorker;
  private _registration?: ServiceWorkerRegistration;
  private _sw?: ServiceWorker;
  private readonly _ownSWs: Set<ServiceWorker> = new Set();
  private _externalSW?: ServiceWorker;
  private _waitingTimeout?: number;

  /**
   * Creates a new Workbox instance with a script URL and service worker
   * options. The script URL and options are the same as those used when
   * calling [navigator.serviceWorker.register(scriptURL, options)](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register).
   *
   * @param {string|TrustedScriptURL} scriptURL The service worker script
   *     associated with this instance. Using a
   *     [`TrustedScriptURL`](https://web.dev/trusted-types/) is supported.
   * @param {Object} [registerOptions] The service worker options associated
   *     with this instance.
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  constructor(scriptURL: string | TrustedScriptURL, registerOptions: {} = {}) {
    super();

    this._scriptURL = scriptURL;
    this._registerOptions = registerOptions;

    // Add a message listener immediately since messages received during
    // page load are buffered only until the DOMContentLoaded event:
    // https://github.com/GoogleChrome/workbox/issues/2202
    navigator.serviceWorker.addEventListener('message', this._onMessage);
  }

  /**
   * Registers a service worker for this instances script URL and service
   * worker options. By default this method delays registration until after
   * the window has loaded.
   *
   * @param {Object} [options]
   * @param {Function} [options.immediate=false] Setting this to true will
   *     register the service worker immediately, even if the window has
   *     not loaded (not recommended).
   */
  async register({immediate = false} = {}): Promise<
    ServiceWorkerRegistration | undefined
  > {
    if (process.env.NODE_ENV !== 'production') {
      if (this._registrationTime) {
        logger.error(
          'Cannot re-register a Workbox instance after it has ' +
            'been registered. Create a new instance instead.',
        );
        return;
      }
    }

    if (!immediate && document.readyState !== 'complete') {
      await new Promise((res) => window.addEventListener('load', res));
    }

    // Set this flag to true if any service worker was controlling the page
    // at registration time.
    this._isUpdate = Boolean(navigator.serviceWorker.controller);

    // Before registering, attempt to determine if a SW is already controlling
    // the page, and if that SW script (and version, if specified) matches this
    // instance's script.
    this._compatibleControllingSW = this._getControllingSWIfCompatible();

    this._registration = await this._registerScript();

    // If we have a compatible controller, store the controller as the "own"
    // SW, resolve active/controlling deferreds and add necessary listeners.
    if (this._compatibleControllingSW) {
      this._sw = this._compatibleControllingSW;
      this._activeDeferred.resolve(this._compatibleControllingSW);
      this._controllingDeferred.resolve(this._compatibleControllingSW);

      this._compatibleControllingSW.addEventListener(
        'statechange',
        this._onStateChange,
        {once: true},
      );
    }

    // If there's a waiting service worker with a matching URL before the
    // `updatefound` event fires, it likely means that this site is open
    // in another tab, or the user refreshed the page (and thus the previous
    // page wasn't fully unloaded before this page started loading).
    // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting
    const waitingSW = this._registration.waiting;
    if (
      waitingSW &&
      urlsMatch(waitingSW.scriptURL, this._scriptURL.toString())
    ) {
      // Store the waiting SW as the "own" Sw, even if it means overwriting
      // a compatible controller.
      this._sw = waitingSW;

      // Run this in the next microtask, so any code that adds an event
      // listener after awaiting `register()` will get this event.
      dontWaitFor(
        Promise.resolve().then(() => {
          this.dispatchEvent(
            new WorkboxEvent('waiting', {
              sw: waitingSW,
              wasWaitingBeforeRegister